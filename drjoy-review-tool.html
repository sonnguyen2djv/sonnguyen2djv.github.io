<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <title>Google Picker Example</title>

  <!-- The Google API Loader script. -->
  <script type="text/javascript" src="https://apis.google.com/js/api.js"></script>
  <script src="my-secrets.js"></script>
  <script src="initGoogleApi.js"></script>
  <script type="text/javascript">

const appId = SECRET.PROJECT_NUMBER;
const SCOPE = 'https://www.googleapis.com/auth/drive';
const DISCOVERY_DOCS = [
  "https://www.googleapis.com/discovery/v1/apis/drive/v3/rest",
  "https://sheets.googleapis.com/$discovery/rest?version=v4"
];
const MAIN_FOLDER_NAME = 'Review tool';
const INPUT_FOLDER_NAME = 'INPUT';
const OUTPUT_FOLDER_NAME = 'OUTPUT';
const FILENAME_PERSONEL_RESPONSE = 'Response list';
const FILENAME_REVIEWREPORT_TEMPLATE = 'Personnel Evaluation Result_template';
const FILENAME_COMPANY_MEMBERS = 'List member';

function findFirstPersonelResponseByEmail(targetEmail, totalPersonelResponse) {
  const personelResponseList = [];
  for (const gradeCode in totalPersonelResponse) {
    if (totalPersonelResponse.hasOwnProperty(gradeCode)) {
      const tempPersonelResponseList = totalPersonelResponse[gradeCode];
      for (const personelResponse of tempPersonelResponseList) {
        if (personelResponse.email === targetEmail) {
          personelResponseList.push(personelResponse);
        }
      }
    }
  }
  if (personelResponseList.length > 1) {
    console.warn(`[WARN] Duplicate email exist in totalPersonelResponse! Email:${targetEmail}`);
  }
  return personelResponseList[0];
}

function readSSFile_PERSONEL_RESPONSE(filePersonelResponse) {
  return new Promise(async (totalResolve, totalReject) => {
    try {
      const totalPersonelResponse = {
        P1: true,
        P2: true,
        P3: true,
        P4: true,
        M1: true,
        M2: true,
      };
      for (const gradeCode in totalPersonelResponse) {
        if (totalPersonelResponse.hasOwnProperty(gradeCode)) {
          const personelResponseList = await new Promise((resolve, reject) => {
            gapi.client.sheets.spreadsheets.values.get({
              spreadsheetId: filePersonelResponse.id,
              range: `${gradeCode}!A2:O200`,
            }).then(response => {
              const personelResponseList = [];
              const rows = response.result.values;
              for (const row of rows) {
                const personelResponse = {};
                personelResponse.timeStamp = trim(row[0]);
                personelResponse.email = trim(row[1]);
                personelResponse.productivity = {
                  text: trim(row[4]),
                  score: trim(row[3]),
                };
                personelResponse.quality = {
                  text: trim(row[6]),
                  score: trim(row[5]),
                };
                personelResponse.deadline = {
                  text: trim(row[8]),
                  score: trim(row[7]),
                };
                personelResponse.kaizen = {
                  text: trim(row[10]),
                  score: trim(row[9]),
                };
                personelResponse.teamwork = {
                  text: trim(row[12]),
                  score: trim(row[11]),
                };
                personelResponse.rule = {
                  text: trim(row[14]),
                  score: trim(row[13]),
                };
                if (personelResponse.email) {
                  personelResponseList.push(personelResponse);
                }
              }
              resolve(personelResponseList);
            }, errorResponse => {
              reject(errorResponse);
            });
          });
          console.log(personelResponseList);
          totalPersonelResponse[gradeCode] = personelResponseList;
        }
      }
      totalResolve(totalPersonelResponse);
    } catch (e) {
      totalReject(e);
    }
  });
}

function readSSFile_COMPANY_MEMBERS(fileCompanyMember) {
  return new Promise((resolve, reject) => {
    gapi.client.sheets.spreadsheets.values.get({
      spreadsheetId: fileCompanyMember.id,
      range: 'Sheet1!A2:G200',
    }).then(response => {
      const staffList = [];
      const rows = response.result.values;
      for (const row of rows) {
        const rowId = trim(row[0]);
        const staff = {};
        staff.name = trim(row[1]);
        staff.position = trim(row[2]);
        staff.grade = trim(row[3]);
        staff.startDate = trim(row[4]);
        staff.email = trim(row[5]);
        staff.team = trim(row[6]);
        if (staff.name) {
          staffList.push(staff);
        }
      }
      resolve(staffList);
    }, errorResponse => {
      reject(new Error(errorResponse.result.error.message));
    });
  });
}
function trim(str) {
  if (str && (typeof str === 'string')) {
    return str.trim();
  } else {
    return str;
  }
}

function throwErrorAndLog(message) {
  console.error(message);
  throw new Error(message);
}

/**@param {DriveFileInfo} mainFolder*/
async function readMainFolder(mainFolder) {
  const mainFolderId = mainFolder.id;
  const inputFolder = (await findFiles(`"${mainFolderId}" in parents and name = "${INPUT_FOLDER_NAME}"`))[0];
  if (!inputFolder) {
    throwErrorAndLog('inputFolder not found!');
  }
  const outputFolderFound = (await findFiles(`"${mainFolderId}" in parents and name = "${OUTPUT_FOLDER_NAME}"`))[0];

  const filePersonelResponse
    = (await findFiles(`"${inputFolder.id}" in parents and name = "${FILENAME_PERSONEL_RESPONSE}"`))[0];
  if (!filePersonelResponse) {
    throwErrorAndLog('filePersonelResponse not found!');
  }
  const fileReviewReportTemplate
    = (await findFiles(`"${inputFolder.id}" in parents and name = "${FILENAME_REVIEWREPORT_TEMPLATE}"`))[0];
  if (!fileReviewReportTemplate) {
    throwErrorAndLog('fileReviewReportTemplate not found!');
  }
  const fileCompanyMember
    = (await findFiles(`"${inputFolder.id}" in parents and name = "${FILENAME_COMPANY_MEMBERS}"`))[0];
  if (!fileCompanyMember) {
    throwErrorAndLog('fileCompanyMember not found!');
  }

  /*
  // Reset output folder.
  if (outputFolderFound) {
    await deleteFileOrFolder(outputFolderFound.id);
  }
  const outputFolder = await createFolder(OUTPUT_FOLDER_NAME, mainFolderId);
  */
  const outputFolder = await createFolder(OUTPUT_FOLDER_NAME+(new Date().getTime()), mainFolderId);

  const staffList = await readSSFile_COMPANY_MEMBERS(fileCompanyMember);
  console.log(staffList);
  const teams = {};
  for (const staff of staffList) {
    if (!teams[staff.team]) {
      teams[staff.team] = {
        staffList: [],
      }
    }
    teams[staff.team].staffList.push(staff);
  }
  for (const teamCodeName in teams) {
    if (teamCodeName && teams.hasOwnProperty(teamCodeName)) {
      teams[teamCodeName].folder = await createFolder(teamCodeName, outputFolder.id);
    }
  }

  const totalPersonelResponse = await readSSFile_PERSONEL_RESPONSE(filePersonelResponse);
  console.log(totalPersonelResponse);

  for (const teamCodeName in teams) {
    if (teams.hasOwnProperty(teamCodeName)) {
      const team = teams[teamCodeName];
      const teamFolder= team.folder;
      const teamStaffList = team.staffList;
      if (!teamFolder || !teamStaffList) {
        console.warn(`Invalid team ${team}`);
      }
      for (const staff of teamStaffList) {
        const staffPersonelResponse = findFirstPersonelResponseByEmail(staff.email, totalPersonelResponse);
        if (!staffPersonelResponse) {
          console.warn(`[WARN] Not found staffPersonelResponse for email ${staff.email}`);
          break;
        }
        const copiedFile = await copyFileToFolderById(fileReviewReportTemplate.id, teamFolder.id, {
          name: staff.name
        });
        console.log(copiedFile);
        const xxx = await writeToSpreadSheet(copiedFile.id, staffPersonelResponse);
        console.log(xxx);
      }
    }
  }

  const noop = 0;
}

function sumScorePersonelResponse(personelResponse) {
  try {
    const totalScore =
      parseInt(personelResponse.productivity.score) +
      parseInt(personelResponse.quality.score) +
      parseInt(personelResponse.deadline.score) +
      parseInt(personelResponse.kaizen.score) +
      parseInt(personelResponse.teamwork.score) +
      parseInt(personelResponse.rule.score);
    return totalScore;
  } catch (e) {
    return 0;
  }
}

function writeToSpreadSheet(fileId, personelResponse) {
  return new Promise((resolve, reject) => {
    const data = [
      {
        range: 'B11:B13',
        values: [
          [personelResponse.productivity.score],
          [personelResponse.quality.score],
          [personelResponse.deadline.score],
        ]
      },
      {
        range: 'C11:C13',
        values: [
          [personelResponse.productivity.text],
          [personelResponse.quality.text],
          [personelResponse.deadline.text],
        ]
      },
      {
        range: 'B15:B17',
        values: [
          [personelResponse.kaizen.score],
          [personelResponse.teamwork.score],
          [personelResponse.rule.score],
        ]
      },
      {
        range: 'C15:C17',
        values: [
          [personelResponse.kaizen.text],
          [personelResponse.teamwork.text],
          [personelResponse.rule.text],
        ]
      },
      {
        range: 'B18:B18',
        values: [
          [sumScorePersonelResponse(personelResponse)],
        ]
      },
    ];
    const body = {
      data: data,
      valueInputOption: 'RAW'
    };
    gapi.client.sheets.spreadsheets.values.batchUpdate({
       spreadsheetId: fileId,
       resource: body
    }).then(response => {
      resolve(response);
    }, err => {
      reject(err);
    });
  });
}

function copyFileToFolderById(fileId, folderId, option) {
  return new Promise((resolve, reject) => {
    gapi.client.drive.files.copy({
      fileId: fileId,
      resource: {
        name: option.name,
        parents: [folderId],
      }
    }).then(response => {
      resolve(response.result);
    }, err => {
      reject(err);
    });
  })
}

function createFolder(folderName, parentFolderId) {
  return new Promise((resolve, reject) => {
    gapi.client.request({
      'path': 'https://www.googleapis.com/drive/v3/files/',
      'method': 'POST',
      'body': {
        "name": folderName,
        "mimeType": "application/vnd.google-apps.folder",
        "parents": [parentFolderId]
      }
    }).then(function(response) {
      console.log(response);
      resolve(response.result);
    });
  });
}

function deleteFileOrFolder(fileOrFolderId) {
  return new Promise((resolve, reject) => {
    gapi.client.drive.files.delete({
      fileId: fileOrFolderId
    }).then(function(response) {
      resolve(response.result.files);
    },
    function(err) {
      reject(err);
    });
  });
}

/**@return {Promise<DriveFileInfo[]>}*/
function findFiles(query) {
  return new Promise((resolve, reject) => {
    return gapi.client.drive.files.list({
      corpora: "user",
      q: query,
    }).then(response => {
      resolve(response.result.files);
    }, err => {
      reject(err);
    });
  });
}

// A simple callback implementation.
function pickerCallback(data) {
  if (data.action === google.picker.Action.PICKED) {
    const selectedFileOrFolder = data.docs[0];
    try {
      readMainFolder(selectedFileOrFolder);
    } catch (e) {
      alert("Invalid folder structure!");
    }
  }
}

function test() {
  initGoogleApi({
    discoveryDocs: DISCOVERY_DOCS,
    scope: SCOPE,
  }, initResponse => {
    const oauthToken = initResponse.authInstance.currentUser.get().getAuthResponse(true).access_token;
    gapi.load('picker', {callback: () => {
      const viewTest = new google.picker.DocsView(google.picker.ViewId.DOCS);
      viewTest.setIncludeFolders(true);
      viewTest.setSelectFolderEnabled(true);

      // const view = new google.picker.View(google.picker.ViewId.DOCS);
      const view = new google.picker.DocsView(google.picker.ViewId.DOCS);
      view.setIncludeFolders(true);
      view.setSelectFolderEnabled(true);
      view.setParent('root');
      //view.setMimeTypes("image/png,image/jpeg,image/jpg");

      const viewShared = new google.picker.DocsView(google.picker.ViewId.DOCS);
      viewShared.setIncludeFolders(true);
      viewShared.setSelectFolderEnabled(true);
      viewShared.setOwnedByMe(false);
      viewShared.setEnableDrives(true);

      const picker = new google.picker.PickerBuilder()
        //.enableFeature(google.picker.Feature.NAV_HIDDEN)
        //.enableFeature(google.picker.Feature.MULTISELECT_ENABLED)
        .enableFeature(google.picker.Feature.SUPPORT_DRIVES)
        .enableFeature(google.picker.Feature.SUPPORT_TEAM_DRIVES)
        .setAppId(appId)
        .setOAuthToken(oauthToken)
        .addView(viewTest)
        .addView(view)
        .addView(viewShared)
        .addView(new google.picker.DocsUploadView())
        //.setDeveloperKey(developerKey)
        .setCallback(pickerCallback)
        .build();
      picker.setVisible(true);
    }});
  }, err => console.error(err));
}

  </script>
</head>
<body>
  <div>
    <button id="elmId_mainBtn" onclick="test();">Select Folder</button>
  </div>
  <div id="result"></div>
</body>
</html>
